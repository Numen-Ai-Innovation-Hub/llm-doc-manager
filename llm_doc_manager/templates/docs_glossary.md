You are an expert technical writer creating a domain glossary.

## TASK
Generate a glossary.md that defines technical terms, concepts, and domain-specific vocabulary used in this project.

## INPUT CONTEXT

### Module Docstrings
{module_docstrings}

### Class Names and Docstrings
{class_definitions}

### Function Names and Docstrings
{function_definitions}

### Variable/Constant Names
{important_names}

### Comments and Inline Documentation
{code_comments}

## OUTPUT REQUIREMENTS

Generate glossary.md with alphabetically organized term definitions.

### Structure

```markdown
# Glossary

Technical terms and concepts used in this project.

## A

**Term**: Definition in one sentence. Extended explanation if needed (1-2 additional sentences with context, examples, or clarifications).

## B

**Another Term**: Clear, concise definition...

[Continue A-Z]
```

### What to Include

1. **Domain-Specific Terms**:
   - Concepts unique to this project's domain
   - Technical jargon specific to the problem space
   - Business/domain entities

2. **Technical Concepts**:
   - Algorithms or data structures used
   - Design patterns implemented
   - Architectural concepts

3. **Project-Specific Terminology**:
   - Internal names for components
   - Specialized vocabulary created for this project
   - Acronyms and abbreviations

4. **Key Classes/Types**:
   - Important data structures
   - Core abstractions
   - Configuration objects

5. **Important Constants/Enums**:
   - Status codes
   - Configuration values
   - Enum types

### What to EXCLUDE

- Common programming terms (e.g., "function", "class", "variable")
- Standard Python concepts unless used in specialized way
- Generic terms that need no explanation
- Implementation details (those belong in API docs)

## DEFINITION GUIDELINES

### Good Definition Structure

**Term**: [One-sentence definition]. [Optional: 1-2 sentences providing context, usage, or examples].

**Examples:**

**Hash**: SHA256 checksum calculated from code content to detect changes. Used for file-level, class-level, and method-level change detection to avoid unnecessary LLM API calls.

**Marker**: Delimiter comment (@llm-doc-start/end) indicating a code block for documentation. Explicitly marks which functions should have docstrings generated by the LLM.

**Queue**: SQLite-backed task queue storing pending documentation work. Persists between runs, allowing incremental processing and restart capability.

### Definition Best Practices

1. **Start with category** (if helpful):
   - "A data structure that..."
   - "A process of..."
   - "A configuration value..."

2. **Be precise but accessible**:
   - Use correct technical terms
   - But explain in understandable language
   - Assume reader knows Python but not the domain

3. **Provide context**:
   - Where/how is it used?
   - Why does it exist?
   - What problem does it solve?

4. **Include examples** (when helpful):
   - Concrete instance of the term
   - Sample value or usage
   - Related terms

5. **Cross-reference** (when relevant):
   - "See also: [Related Term]"
   - Link to docs: "See [Module Name](api/module.md) for details"

## ORGANIZATION

### Alphabetical Sections

Group terms by first letter (A, B, C, ...).

Skip letters with no terms.

Within each letter section:
- Sort alphabetically
- Use consistent formatting
- Bold the term, regular text for definition

### Cross-References

When terms relate:
- Mention related terms
- Use "See also:" at end of definition
- Link to API docs when applicable

Example:
**Task**: Database record representing documentation work to be done. Stored in documentation_tasks table with status (pending, completed, failed). See also: [Queue](#queue), [API: QueueManager](api/queue.md).

## CRITICAL RULES

1. **EXTRACT FROM CODE**:
   - Don't invent terms
   - Base on actual class/function/variable names
   - Use docstrings as source of truth

2. **ONE SENTENCE FIRST**:
   - Definition starts with complete sentence
   - Can expand with 1-2 more sentences if needed
   - But first sentence must stand alone

3. **AVOID REDUNDANCY**:
   - Don't define common programming terms
   - Don't repeat what's in API docs (link instead)
   - Don't explain implementation (that's for architecture docs)

4. **CONSISTENCY**:
   - Use same terminology throughout
   - Match names used in code exactly
   - Be consistent with capitalization

5. **CLARITY OVER COMPLETENESS**:
   - Better to have 20 clear definitions than 50 vague ones
   - Focus on terms that genuinely need explanation
   - Skip obvious stuff

## TERM IDENTIFICATION STRATEGY

### From Class Names
Look for:
- Core abstractions (Scanner, Processor, Manager)
- Data structures (Task, Block, Result)
- Patterns (Factory, Builder, Observer)

### From Function Names
Look for:
- Key operations (detect, process, validate)
- Domain actions (scan, generate, apply)
- Transformations (parse, extract, convert)

### From Constants/Enums
Look for:
- Status values (PENDING, COMPLETED)
- Configuration keys
- Type indicators

### From Comments/Docstrings
Look for:
- Explanations of non-obvious concepts
- Domain-specific terminology
- Acronyms that are defined

## OUTPUT FORMAT

Provide ONLY the complete glossary.md content in Markdown format.
Do NOT include explanations or meta-commentary.
Start directly with the content.

## QUALITY CHECKS

Before finalizing, verify:
- [ ] All terms are actually used in the project (not invented)
- [ ] Definitions are clear and concise (one sentence + optional context)
- [ ] Alphabetically organized
- [ ] No common/obvious terms (function, class, etc.)
- [ ] Cross-references are accurate
- [ ] Links to API docs work (use relative paths)

---

Now analyze the provided codebase and generate glossary.md.